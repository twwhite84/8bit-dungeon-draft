---=== NOTES ===--- 

18/10/2025

Problem: when sprite is drawn, its sprite container doesn't contain any statics 
in proximity.
- If I render my statics after the player, the player gets obscured by 
background and static.
- If I render my player before my statics, the player container overwrites 
statics with bg when in proximity, eg walls.

I will need to triple composite in situations where a player and static overlap.
The redraw player camera flag is raised on player movement and animation cycles.
When player is moved, proximity check with static is performed.
I could potentially pass the static pointer as an argument to the function for
player rendering, and so only triple composite on that case.

I could repurpose the clean flag on the static to signify that the static will
have its rendering deferred to the player rendering function so that it is
composited. Con: when rendering player I will need to rescan all statics for
those which have been marked as deferred. Pro: I can more easily handle multi
static overlap.

A may more efficient way may be to just set aside an additional couple of bytes
next to the erase buffer that the call to render player checks in order to do
any triple compositing necessary. At this point I effectively have two kinds of
statics: triple-composited if overlapped with player, and double-composited if
not.

--------------------------------------------------------------------------------

17/10/2025

Suppose I want to pick up an item in one room and drop it in another.

First modify the loadStatics() function to take a flag indicating whether to 
mark all items for redraw.

PICK UP:
- copy item pointer to the player inventory
- copy item pointer to the erase slot (allows multiquad statics to be cleared)
- change the item's room code to null
- loadStatics(redraw_all=false); the null room code will cause it to be excluded
    and render_all false skips unnecessarily raising redraw flag on all items.

Don't need a camera erase flag. There will typically only be one item to check,
so just do the erase on each frame checking if the slot is populated.

Disconsidered options:
- A: remove from roombuffer and re-sort. 
    con: requires new code and more ram.
- B: leave item in the roombuffer with null room, then implement code to skip nulls.
    - con: zombie items left consuming camera slots.
    - con: need to check room ids more often to skip zombie items

DROP:
- delete item pointer from player inventory
- change the room code on the item to match the current room
- raise the redraw flag on the item and the REDRAW_STATICS flag on the camera.
    this will redraw all statics marked for redraw.
- reload the room items; the roombuffer will now contain the item

--------------------------------------------------------------------------------

16/10/2025

Suppose I walk over a pickup, which is a static item. This results in:
- a player inventory update
- background redrawn over the item's tile
- player being redrawn over the background
- the item's roomID being changed to a not-in-any-room value
- the roombuffer being refreshed with a call to loadStatics()
    (collisions are checked against roombuffer; this actually removes the item)


Rendering optimisation thoughts...

UNSORTED ROOMBUFFER
- suppose the REDRAW_STATICS flag is raised on the camera.
- suppose I have 1 static that needs to be redrawn, but this is not known A.O.T
- suppose roombuffer has capacity for 14 items, but currently holds 7 items plus
    a sentinel value to stop early.
- without sorting I must visit all items in roombuffer preceding the sentinel.
- on each item visited in roombuffer preceding sentinel:
    - 1 sentinel check
	- 1 type check
	- if type==static, then redraw flag check

Worst case: 7 sentinels, 7 type checks, 1 flag check + end sentinel = 16 checks


CATEGORISED ROOMBUFFER
- suppose the REDRAW_STATICS flag is raised on the camera.
- suppose I have 1 static that needs to be redrawn, but this is not known A.O.T
- suppose statics section of roombuffer has capacity 10 items, but holds 1 item 
    and a sentinel to stop early
- I only visit statics in the roombuffer to check their redraw flags. These are 
    presorted, so no type checks needed.
- on each item visited in the statics section preceding sentinel:
	- 1 sentinel check
	- 0 type checks
	- 1 redraw flag check
	
Worst case: 1 sentinel check, 1 redraw check, 1 final sentinel check = 3 checks

If I do opt to use a renderqueue, then this doesn't really change much. I'll
still need a sentinel to stop early due to fixed size. If I don't keep render 
items sorted then I also need to check times as I visit each item in the queue.

--------------------------------------------------------------------------------

07/10/2025

When I move quickly (eg by 2+ pixels per frame) sometimes a trail gets left 
behind. I think this is because my character moves to a new sprite container 
without clearing the old one. Perhaps I need to implement an erase when my 
character is running.

I already track the direction of travel. Perhaps I can implement only redrawing 
those background tiles prior to the sprite container update. When I perform the 
sprite container update, I could check for when the hshift or vshift wraps 
around and also delete those cells related to the player direction.

--------------------------------------------------------------------------------

30/09/2025

Animation Problem

GOAL: AVOID HAVING SEPARATE FUNCTIONS TO ANIMATE PLAYER VERSUS ENEMIES AND OTHER
MOVABLE OBJECTS

option #1: store pointers to animation sets directly on each movable / player 
with common label e.g. ME_UP, ME_DOWN, etc. this will increase the size of each 
movable a lot as more animation sets are added, so probably wont scale well

option #2: store an absolute offset from animdefs start on each movable / player. 
this is essentially the same as storing a pointer on each object but you save a 
byte.

option #3: store a base + relative offset on each movable / player without a 
pointer table.  this requires the various animation sets to be laid out in a 
common order AND size. 
(eg PLAYER U 3 frames, D 3 frames ... ENEMY U 3 frames, D 3 frames ...)

option #4: store a base + relative offset on each movable / player with a 
pointer table. this requires animation sets to share a common order, but size 
can be variable. 
(eg PLAYER U 3 frames, D 3 frames ... ENEMY U 2 frames, D 2 frames ... )

I AM GOING WITH OPTION #4 FOR NOW

Layout Example

-shared.h-
ME_ANIMOFF_WALKU = 0,
ME_ANIMOFF_WALKD = 2,
ME_ANIMOFF_WALKL = 4,
ME_ANIMOFF_WALKR = 6,

ANIMBASE: Player = 0xnnnn
ANIMBASE: Enemey = 0xnnnn
etc

to access:
Player+ME_ANIMOFF_WALKU
Enemy+ME_ANIMOFF_WALKU
// this is called when a request for movement is made
void movePlayer() {

    // get current bearing
    uint8_t xdir = (beebram[PLAYER + ME_DIRX4_DIRY4] >> 4) & 0b11;
    uint8_t xboost = (beebram[PLAYER + ME_DIRX4_DIRY4] >> 4) >> 2;
    uint8_t ydir = (beebram[PLAYER + ME_DIRX4_DIRY4] & 0x0F) & 0b11;
    uint8_t yboost = (beebram[PLAYER + ME_DIRX4_DIRY4] & 0x0F) >> 2;

    // get the current coordinates
    uint16_t x0 = beebram[PLAYER + ME_X_LO] | (beebram[PLAYER + ME_X_HI] << 8), x1 = x0;
    uint16_t y0 = beebram[PLAYER + ME_Y_LO] | (beebram[PLAYER + ME_Y_HI] << 8), y1 = y0;

    // if player is at a screen edge, abort movement
    if (y1 < 2 && ydir == DIR_NEGATIVE)
        ydir = DIR_ZERO;
    if (y1 > (CAMERA_HEIGHT - 19) && ydir == DIR_POSITIVE)
        ydir = DIR_ZERO;
    if (x1 < 1 && xdir == DIR_NEGATIVE)
        xdir = DIR_ZERO;
    if (x1 > (CAMERA_WIDTH - 18) && xdir == DIR_POSITIVE)
        xdir = DIR_ZERO;

    // don't move player if path blocked by a wall
    {
    movex:
        if (xdir != DIR_ZERO) {
            x1 = (xdir == DIR_NEGATIVE) ? (x1 - 1 - xboost) : (x1 + 1 + xboost); // potential target x
            uint8_t i1 = y1 >> 3;
            uint8_t j1 = x1 >> 3;
            uint8_t hshift1 = x1 & 0b111;
            uint8_t vshift1 = y1 & 0b111;

            // when target is flush with container top, dont check bottom container row
            // this is the only case where a player can travel x through player-height gaps
            uint8_t ilimit = (vshift1 == 0) ? 2 : 3;

            /* -------------------- WALLS CHECK --------------------*/
            bool wall_present = false;

            // check each tile in the 3x3 (or 2x3) container area
            for (uint8_t i = i1; i < (i1 + ilimit); i++) {
                for (uint8_t j = j1; j < (j1 + 3); j++) {
                    uint8_t tid = beebram[CAMBUFFER + 40 * i + j];
                    if (tid >= TID_WALLS) {
                        // stop x movement if wall present, unless moving to a grid-aligned position
                        // (this exception allows subsequent y movement through player-wide gaps)
                        if (hshift1 != 0) {
                            x1 = x0;
                            wall_present = true;
                            break;
                        }
                    }
                }
                if (wall_present)
                    break;
            }

            /* -------------------- STATICS CHECK --------------------*/
            // if (wall_present)
            // goto movey;

            uint8_t collision_type = checkStaticCollisions(PLAYER, x1, y1);
            switch (collision_type) {
            case 0xFF:
                break;
            case SETYPE_DOORLOCKED:
                if (xdir != DIR_ZERO) {
                    fprintf(stderr, "\nLOCKED DOOR on X-axis ");
                    (xdir == DIR_NEGATIVE) ? fprintf(stderr, " LEFT") : fprintf(stderr, " RIGHT");
                    x1 = x0;
                }
            }
        }

    movey:
        if (ydir != DIR_ZERO) {
            y1 = (ydir == DIR_NEGATIVE) ? (y1 - 1 - yboost) : (y1 + 1 + yboost); // potential target y
            uint8_t i1 = y1 >> 3;
            uint8_t j1 = x1 >> 3;
            uint8_t hshift1 = x1 & 0b111;
            uint8_t vshift1 = y1 & 0b111;
            uint8_t jlimit = (hshift1 == 0) ? 2 : 3;

            /* -------------------- WALLS CHECK --------------------*/
            bool wall_present = false;
            for (uint8_t i = i1; i < (i1 + 3); i++) {
                for (uint8_t j = j1; j < (j1 + jlimit); j++) {
                    uint8_t tid = beebram[CAMBUFFER + 40 * i + j];
                    if (tid >= TID_WALLS) {

                        // stop y movement if wall present, unless moving to a grid-aligned position
                        // (this exception allows subsequent x movement through player-height gaps)
                        if (vshift1 != 0) {
                            y1 = y0;
                            wall_present = true;
                            break;
                        }
                    }
                }
                if (wall_present)
                    break;
            }

            /* -------------------- STATICS CHECK --------------------*/
            // if (wall_present)
            // goto save;

            uint8_t collision_type = checkStaticCollisions(PLAYER, x1, y1);
            switch (collision_type) {
            case 0xFF:
                break;
            case SETYPE_DOORLOCKED:
                if (ydir != DIR_ZERO) {
                    fprintf(stderr, "\nLOCKED DOOR on Y-axis ");
                    (ydir == DIR_NEGATIVE) ? fprintf(stderr, " UP") : fprintf(stderr, " DOWN");
                    y1 = y0;
                }
            }
        }
    }

save:
    // save the updated coordinates
    beebram[PLAYER + ME_X_LO] = x1 & 0xFF;
    beebram[PLAYER + ME_X_HI] = x1 >> 8;
    beebram[PLAYER + ME_Y_LO] = y1 & 0xFF;
    beebram[PLAYER + ME_Y_HI] = y1 >> 8;

    // update the sprite container with its new coordinates
    updateSpriteContainer(PLAYER);

    // raise the redraw flag to let renderer know movement has taken place
    beebram[PLAYER + CE_ROOMID6_CLEAN1_REDRAW1] |= true;
}